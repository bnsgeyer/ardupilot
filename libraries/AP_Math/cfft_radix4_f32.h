#pragma once

#include "rfft_common_tables.h"

#define ARM_MATH_DSP          1

typedef enum
{
    ARM_MATH_SUCCESS = 0,                /**< No error */
    ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
    ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
    ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
    ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
    ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
    ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
} arm_status;

typedef struct
{
    uint16_t fftLen;                   /**< length of the FFT. */
    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
    float *pTwiddle;               /**< points to the Twiddle factor table. */
    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
    float onebyfftLen;             /**< value of 1/fftLen. */
} arm_cfft_radix4_instance_f32;

arm_status arm_cfft_radix4_init_f32( arm_cfft_radix4_instance_f32 * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag);

void arm_cfft_radix4_f32( arm_cfft_radix4_instance_f32 * S, float * pSrc);

extern void arm_bitreversal_f32(float * pSrc,uint16_t fftSize,uint16_t bitRevFactor,uint16_t * pBitRevTab);

void arm_radix4_butterfly_f32(float * pSrc,uint16_t fftLen,float * pCoef,uint16_t twidCoefModifier);

void arm_radix4_butterfly_inverse_f32(float * pSrc,uint16_t fftLen,float * pCoef,uint16_t twidCoefModifier,float onebyfftLen);



